package 	{	// Class generated by Prefab3D. David Lenaerts & Fabrice Closier, 2010.	import away3d.arcane;	import away3d.cameras.lenses.PerspectiveLens;	import away3d.containers.View3D;	import away3d.core.base.Object3D;	import away3d.core.clip.NearfieldClipping;	import away3d.graphs.ITreeNode;	import away3d.graphs.TreeIterator;	import away3d.graphs.bsp.BSPNode;	import away3d.graphs.bsp.BSPTree;	import away3d.core.math.MatrixAway3D;	import away3d.core.math.Number3D;	import away3d.loaders.AWData;	import away3d.physics.BSPCollider;	import flash.display.*;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.ui.Keyboard;	use namespace arcane;	[SWF(backgroundColor="#000000", frameRate="60", quality="LOW", width="800", height="600")]		public class Intermediate_BSPBunker extends Sprite	{		[Embed(source="bunker/myBunkerTree.awd", mimeType="application/octet-stream")]		private var BSPFile:Class;		private static const MOVE_SPEED:Number = 250;		private static const JUMP_STRENGTH:Number = 300;		private static const ACCELERATION:Number = 70;		private static const RUN_MULTIPLIER:Number = 2;		private static const GRAVITY:Number = 30;		private static const FRICTION:Number = .3;		private var _lastMouseX:Number;		private var _lastMouseY:Number;		private var _lastRotX:Number;		private var _lastRotY:Number;		private var _rotX:Number;		private var _rotY:Number;		private var _right:Boolean;		private var _left:Boolean;		private var _rotaccel:Number = 0.0;		private var _tree:BSPTree;		private var _view:View3D;		private var _xDir:Number = 0.0;		private var _zDir:Number = 0.0;		private var _mouseDown:Boolean;		private var _dragX:Number = 0;		private var _dragY:Number = 0;		private var _bspCollider:BSPCollider;		private var _force:Number3D = new Number3D();		private var _flightMode:Boolean = false;		private var _speedMultiplier:Number = 1.0;		private var _noClip:Boolean = false;		public function Intermediate_BSPBunker()		{			addEventListener(Event.ADDED_TO_STAGE, init);		}		private function init(e:Event):void		{			initStage();			initAway3D();		}		private function initStage():void		{			stage.scaleMode = StageScaleMode.NO_SCALE;			stage.quality = StageQuality.LOW;			stage.addEventListener(KeyboardEvent.KEY_DOWN, KeyIsDown);			stage.addEventListener(KeyboardEvent.KEY_UP, KeyIsUP);			stage.addEventListener(MouseEvent.MOUSE_DOWN, onMouseIsDown);			stage.addEventListener(MouseEvent.MOUSE_UP, onMouseIsUp);		}		private function initAway3D():void		{			_view = new View3D({x: stage.stageWidth*.5, y: stage.stageHeight*.5, clipping: new NearfieldClipping({minZ:10})});			_view.camera.lens = new PerspectiveLens();			_view.camera.zoom = 6;			_view.camera.x = 2000;			_view.camera.y = -170;			_view.camera.z = -148;			_view.camera.rotationX = 0;			_view.camera.rotationY = 224;			_view.camera.rotationZ = 0;			_tree = BSPTree(AWData.parse(new BSPFile(), {customPath:"./bunker/images/"}));			_view.scene.addChild(_tree);			_tree.usePVS = true;			_bspCollider = new BSPCollider(_view.camera, _tree);			_bspCollider.testMethod = BSPTree.TEST_METHOD_ELLIPSOID;			_bspCollider.flyMode = _flightMode;			_bspCollider.maxClimbHeight = 50;			_bspCollider.maxIterations = 4;			_bspCollider.minBounds = new Number3D(-80,-860,-80);			_bspCollider.maxBounds = new Number3D(80,40,80);			addChild(_view);			addEventListener(Event.ENTER_FRAME, onEnterFrame);		}		private function KeyIsDown(event:KeyboardEvent):void		{			switch(event.keyCode) {				case Keyboard.UP:					_zDir = 1;					break;				case Keyboard.DOWN:					_zDir = -1;					break;				case Keyboard.LEFT:					_left = true;					break;				case Keyboard.RIGHT:					_right = true;					break;				case Keyboard.SPACE:					if(_bspCollider && _bspCollider.onSolidGround) _force.y = JUMP_STRENGTH;					break;				case Keyboard.SHIFT:					_speedMultiplier = RUN_MULTIPLIER;					break;			}		}		private function KeyIsUP(event:KeyboardEvent):void		{			switch(event.keyCode) {				case Keyboard.UP:				case Keyboard.DOWN:					_zDir = 0;					break;				case Keyboard.RIGHT:					_right=false;					break;				case Keyboard.LEFT:					_left=false;					break;				case Keyboard.ENTER:					_tree.usePVS = !_tree.usePVS;					break;				case Keyboard.SHIFT:					_speedMultiplier = 1;					break;				case Keyboard.F1:					_noClip = !_noClip;					break;			}		}		private function onEnterFrame(event:Event):void		{			var maxSpeed:Number = MOVE_SPEED*_speedMultiplier;			if(_mouseDown){				_rotX = _lastMouseX - (mouseY - _lastRotY)*0.7;				_rotY = _lastMouseY + (mouseX - _lastRotX)*0.7;				if(_rotX > 90) _rotX = 70;				if(_rotX < -90) _rotX = -70;				_view.camera.rotationX += (_rotX - _view.camera.rotationX)/4;				_view.camera.rotationY += (_rotY - _view.camera.rotationY)/4;			}			if(_right) {				_rotaccel+=.2;				_view.camera.rotationY += (_rotaccel>5)? _rotaccel:5;			}			if(_left) {				_rotaccel-=.2;				_view.camera.rotationY += (_rotaccel<-5)? _rotaccel:-5;			}			if(_noClip || !_bspCollider) {				_view.camera.moveForward(_zDir*maxSpeed);			}			else {				var dx:Number = _xDir*ACCELERATION;				var dz:Number = _zDir*ACCELERATION;				_force.x += dx;				_force.z += dz;				if(_force.x > maxSpeed || _force.x < -maxSpeed) _force.x -= dx;				if(_force.z > maxSpeed || _force.z < -maxSpeed) _force.z -= dz;				if(_flightMode) {					_bspCollider.move(_xDir * maxSpeed, 0, _zDir * maxSpeed);				}				else {					_force.y = _bspCollider.move(_force.x, _force.y, _force.z).y;					_force.x /= (1+FRICTION);					_force.z /= (1+FRICTION);					_force.y -= GRAVITY;				}			}			_view.render();		}		private function onMouseIsDown(event:MouseEvent):void		{			_lastMouseX = _view.camera.rotationX;			_lastMouseY = _view.camera.rotationY;			_lastRotX = mouseX;			_lastRotY = mouseY;			_mouseDown = true;			_dragX = mouseX;			_dragY = mouseY;		}		private function onMouseIsUp(event:MouseEvent):void		{			_mouseDown = false;		}	}	}